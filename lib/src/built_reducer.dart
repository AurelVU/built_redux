import 'package:built_value/built_value.dart';

import 'action.dart';
import 'typedefs.dart';

abstract class BuiltReducer<V extends Built<V, B>, B extends Builder<V, B>> implements Built<V, B> {
  /// This is a map, not a single function with switch statement as per js redux implementation.
  /// This is so each reducer can have the action payload generic be a different non dynamic value
  Map<String, Reducer<dynamic, V, B>> get reducer;

  void reduce(V state, Action<dynamic> a, B builder) {
    var handler = reducer[a.name];
    // TODO: warn if payload type doesn't match reducer
    if (handler != null) handler(state, a, builder);

    reduceChildren(state, a, builder);
  }

  /// Generated by the transformer for developer convienience
  /// It will call reduce on any properties of your [BuiltReduer] that are also of type [BuiltReducer]
  void reduceChildren(V state, Action<dynamic> a, B builder) {}
}

/// [ReducerBuilder] allows you to build a reducer that handles many different actions
/// with many different payload types, while maintaining type safety.
/// Each [Reducer] added with add<T> must take a state of type V, an Action of type
/// Action<T>, and a builder of type B
class ReducerBuilder<V extends BuiltReducer<V, B>, B extends Builder<V, B>> {
  var _map = new Map<String, Reducer<dynamic, V, B>>();

  add<T>(ActionName<T> aName, Reducer<T, V, B> reducer) => _map[aName.name] = reducer;

  build() => _map;
}
